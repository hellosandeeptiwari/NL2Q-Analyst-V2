"""
SQL Runner - Simple execution engine for LLM-generated SQL
The SQL generation is handled by LLM agents, this just executes safely
"""

import asyncio
import time
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from datetime import datetime

@dataclass
class QueryValidationResult:
    is_valid: bool
    error_message: Optional[str] = None
    warnings: List[str] = None

@dataclass
class QueryExecutionResult:
    success: bool
    data: List[Dict[str, Any]] = None
    columns: List[str] = None
    execution_time: float = 0.0
    row_count: int = 0
    error_message: Optional[str] = None
    job_id: Optional[str] = None

class SQLRunner:
    """
    Simple SQL Runner for executing LLM-generated SQL queries
    
    The SQL generation logic is handled by LLM agents that use:
    - User intent analysis 
    - Stable schema information
    - Column-level metadata
    - Join relationships
    
    This class only handles safe execution of the generated SQL.
    """
    
    def __init__(self):
        self.db_adapter = None

    async def execute_query(self, 
                          sql: str, 
                          user_id: str = "default_user",
                          **kwargs) -> QueryExecutionResult:
        """
        Execute LLM-generated SQL query safely
        
        Args:
            sql: SQL query generated by LLM agents
            user_id: User identifier
            
        Returns:
            QueryExecutionResult with data and metadata
        """
        start_time = time.time()
        
        try:
            # Initialize database adapter if needed
            if not self.db_adapter:
                from backend.db.engine import get_adapter
                self.db_adapter = get_adapter()
            
            # Execute the SQL query
            result = self.db_adapter.run(sql, dry_run=False)
            
            execution_time = time.time() - start_time
            
            if result.error:
                return QueryExecutionResult(
                    success=False,
                    error_message=result.error,
                    execution_time=execution_time
                )
            
            # 🔧 CRITICAL DEBUG: Check what we're actually getting from the database
            print(f"🔍 DEBUG SQL Result:")
            print(f"  - result.error: {result.error}")
            print(f"  - result.rows type: {type(result.rows)}")
            print(f"  - result.rows length: {len(result.rows) if result.rows else 0}")
            print(f"  - result.columns type: {type(result.columns)}")
            print(f"  - result.columns length: {len(result.columns) if result.columns else 0}")
            if result.rows:
                print(f"  - First row: {result.rows[0] if len(result.rows) > 0 else 'None'}")
            if result.columns:
                print(f"  - Columns: {result.columns}")
            
            # 🔧 ENHANCED: Convert rows to list of dictionaries with intelligent column handling
            data = []
            if result.rows:
                if result.columns:
                    # Ideal case: we have column names
                    for row in result.rows:
                        row_dict = dict(zip(result.columns, row))
                        data.append(row_dict)
                else:
                    # 🔧 INTELLIGENT FALLBACK: Try to extract column names from SQL query
                    print("⚠️ WARNING: Column names missing, attempting intelligent extraction")
                    try:
                        extracted_columns = self._extract_column_names_from_sql(sql)
                    except Exception as e:
                        print(f"⚠️ Column extraction failed: {e}")
                        extracted_columns = None
                    
                    if extracted_columns and result.rows:
                        num_data_columns = len(result.rows[0]) if result.rows[0] else 0
                        if len(extracted_columns) == num_data_columns:
                            print(f"✅ Successfully extracted {len(extracted_columns)} column names from SQL")
                            print(f"🔧 Extracted columns: {extracted_columns}")
                            result.columns = extracted_columns
                        else:
                            print(f"⚠️ Column count mismatch: extracted {len(extracted_columns)}, data has {num_data_columns}")
                            extracted_columns = None
                    
                    if not extracted_columns:
                        # Ultimate fallback: generate generic names
                        if result.rows:
                            num_columns = len(result.rows[0]) if result.rows[0] else 0
                            extracted_columns = [f"column_{i+1}" for i in range(num_columns)]
                            print(f"🔧 Generated fallback column names: {extracted_columns}")
                        
                    if extracted_columns:
                        for row in result.rows:
                            row_dict = dict(zip(extracted_columns, row))
                            data.append(row_dict)
                        
                        # Update result.columns for return value
                        result.columns = extracted_columns
            
            print(f"🔍 DEBUG Final Data: {len(data)} rows converted")
            if data:
                print(f"  - First converted row: {data[0]}")
            
            return QueryExecutionResult(
                success=True,
                data=data,
                columns=result.columns or [],
                execution_time=execution_time,
                row_count=len(data) if data else 0
            )
            
        except Exception as e:
            execution_time = time.time() - start_time
            return QueryExecutionResult(
                success=False,
                error_message=str(e),
                execution_time=execution_time
            )
    
    def _extract_column_names_from_sql(self, sql: str) -> List[str]:
        """Intelligently extract column names from SQL SELECT statement"""
        try:
            # Clean up the SQL
            sql_cleaned = sql.strip().upper()
            if not sql_cleaned.startswith('SELECT'):
                return []
            
            # Find the SELECT clause
            select_start = sql_cleaned.find('SELECT') + 6
            from_pos = sql_cleaned.find('FROM')
            if from_pos == -1:
                return []
            
            # Extract the column part
            columns_part = sql[select_start:from_pos].strip()
            
            # Handle TOP clause
            if columns_part.upper().startswith('TOP '):
                # Skip TOP N clause
                parts = columns_part.split(' ', 2)
                if len(parts) >= 3:
                    columns_part = parts[2]
            
            # Split by comma and clean up
            column_names = []
            for col in columns_part.split(','):
                col = col.strip()
                
                # Handle aliases (AS keyword or space-separated)
                if ' AS ' in col.upper():
                    col = col.split(' AS ')[-1].strip()
                elif ' ' in col and not any(func in col.upper() for func in ['TOP', 'DISTINCT', 'COUNT', 'SUM', 'AVG', 'MAX', 'MIN']):
                    # Check if it's an alias (column alias)
                    parts = col.split()
                    if len(parts) >= 2:
                        col = parts[-1]  # Take the last part as alias
                
                # Remove brackets and clean
                col = col.replace('[', '').replace(']', '').replace('"', '').replace("'", "")
                
                # Skip empty or problematic columns
                if col and col != '*' and not col.upper() in ['DISTINCT', 'TOP']:
                    column_names.append(col)
            
            # If we have SELECT *, return empty (can't determine columns)
            if '*' in columns_part:
                return []
            
            return column_names[:10]  # Limit to reasonable number
            
        except Exception as e:
            print(f"🚨 Error extracting column names: {e}")
            return []

    async def validate_query(self, sql: str, user_id: str = "default_user") -> QueryValidationResult:
        """
        Basic SQL validation (syntax only)
        The actual SQL generation logic with intent and schema is handled by LLM agents
        """
        try:
            # Basic syntax check using sqlparse if available
            try:
                import sqlparse
                parsed = sqlparse.parse(sql)
                if not parsed:
                    return QueryValidationResult(
                        is_valid=False,
                        error_message="Invalid SQL syntax"
                    )
                    
                # Check for obviously dangerous patterns
                sql_upper = sql.upper()
                dangerous_patterns = ["DROP TABLE", "DELETE FROM", "TRUNCATE", "ALTER TABLE"]
                for pattern in dangerous_patterns:
                    if pattern in sql_upper:
                        return QueryValidationResult(
                            is_valid=False,
                            error_message=f"Dangerous SQL pattern detected: {pattern}"
                        )
                        
                return QueryValidationResult(is_valid=True)
                
            except ImportError:
                # If sqlparse not available, just do basic checks
                if not sql.strip():
                    return QueryValidationResult(
                        is_valid=False,
                        error_message="Empty SQL query"
                    )
                return QueryValidationResult(is_valid=True)
                
        except Exception as e:
            return QueryValidationResult(
                is_valid=False,
                error_message=f"Validation error: {str(e)}"
            )
